"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function wrap(code) {
    return '!(function () {' + code + '})();';
}
function default_1(compiler, next) {
    compiler.shims.push(wrap(compiler.getHeader()));
    compiler.shims.push(wrap("\n    if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n      const cluster = require('cluster')\n      cluster._setupWorker()\n      delete process.env.NODE_UNIQUE_ID\n    }\n  "));
    if (compiler.options.resources.length) {
        compiler.shims.push(wrap("\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar assert_1 = require(\"assert\");\r\nvar path_1 = require(\"path\");\r\nvar binary = process.__nexe;\r\nassert_1.ok(binary);\r\nvar manifest = binary.resources;\r\nvar directories = {};\r\nvar isString = function (x) { return typeof x === 'string' || x instanceof String; };\r\nvar isNotFile = function () { return false; };\r\nvar isNotDirectory = isNotFile;\r\nvar isFile = function () { return true; };\r\nvar isDirectory = isFile;\r\nif (Object.keys(manifest).length) {\r\n    var fs_1 = require('fs');\r\n    var originalReadFile_1 = fs_1.readFile;\r\n    var originalReadFileSync_1 = fs_1.readFileSync;\r\n    var originalCreateReadStream_1 = fs_1.createReadStream;\r\n    var originalReaddir_1 = fs_1.readdir;\r\n    var originalReaddirSync_1 = fs_1.readdirSync;\r\n    var originalStatSync_1 = fs_1.statSync;\r\n    var originalStat_1 = fs_1.stat;\r\n    var resourceStart_1 = binary.layout.resourceStart;\r\n    var statTime_1 = function () {\r\n        var stat = binary.layout.stat;\r\n        return {\r\n            dev: 0,\r\n            ino: 0,\r\n            nlink: 0,\r\n            rdev: 0,\r\n            uid: 123,\r\n            gid: 500,\r\n            blksize: 4096,\r\n            blocks: 0,\r\n            atime: new Date(stat.atime),\r\n            atimeMs: stat.atime.getTime(),\r\n            mtime: new Date(stat.mtime),\r\n            mtimeMs: stat.mtime.getTime(),\r\n            ctime: new Date(stat.ctime),\r\n            ctimMs: stat.ctime.getTime(),\r\n            birthtime: new Date(stat.birthtime),\r\n            birthtimeMs: stat.birthtime.getTime()\r\n        };\r\n    };\r\n    var createStat_1 = function (directoryExtensions, fileExtensions) {\r\n        if (!fileExtensions) {\r\n            return Object.assign({}, binary.layout.stat, directoryExtensions, { size: 0 }, statTime_1());\r\n        }\r\n        var size = directoryExtensions[1];\r\n        return Object.assign({}, binary.layout.stat, fileExtensions, { size: size }, statTime_1());\r\n    };\r\n    var ownStat_1 = function (path) {\r\n        var key = path_1.resolve(path);\r\n        if (directories[key]) {\r\n            return createStat_1({ isDirectory: isDirectory, isFile: isNotFile });\r\n        }\r\n        if (manifest[key]) {\r\n            return createStat_1(manifest[key], { isFile: isFile, isDirectory: isNotDirectory });\r\n        }\r\n    };\r\n    var setupManifest_1 = function () {\r\n        Object.keys(manifest).forEach(function (key) {\r\n            var absolutePath = path_1.resolve(key);\r\n            var dirPath = path_1.dirname(absolutePath);\r\n            directories[dirPath] = directories[dirPath] || {};\r\n            directories[dirPath][path_1.basename(absolutePath)] = true;\r\n            if (!manifest[absolutePath]) {\r\n                manifest[absolutePath] = manifest[key];\r\n            }\r\n            var normalizedPath = path_1.normalize(key);\r\n            if (!manifest[normalizedPath]) {\r\n                manifest[normalizedPath] = manifest[key];\r\n            }\r\n        });\r\n        setupManifest_1 = function () { };\r\n    };\r\n    //naive patches intended to work for most use cases\r\n    var nfs = {\r\n        readdir: function readdir(path, options, callback) {\r\n            setupManifest_1();\r\n            path = path.toString();\r\n            if ('function' === typeof options) {\r\n                callback = options;\r\n                options = { encoding: 'utf8' };\r\n            }\r\n            var dir = directories[path_1.resolve(path)];\r\n            if (dir) {\r\n                process.nextTick(function () {\r\n                    callback(null, Object.keys(dir));\r\n                });\r\n            }\r\n            else {\r\n                return originalReaddir_1.apply(fs_1, arguments);\r\n            }\r\n        },\r\n        readdirSync: function readdirSync(path, options) {\r\n            setupManifest_1();\r\n            path = path.toString();\r\n            var dir = directories[path_1.resolve(path)];\r\n            if (dir) {\r\n                return Object.keys(dir);\r\n            }\r\n            return originalReaddirSync_1.apply(fs_1, arguments);\r\n        },\r\n        readFile: function readFile(file, options, callback) {\r\n            setupManifest_1();\r\n            var entry = manifest[file];\r\n            if (!entry || !isString(file)) {\r\n                return originalReadFile_1.apply(fs_1, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart_1 + offset;\r\n            var encoding = isString(options) ? options : null;\r\n            callback = typeof options === 'function' ? options : callback;\r\n            fs_1.open(process.execPath, 'r', function (err, fd) {\r\n                if (err)\r\n                    return callback(err, null);\r\n                fs_1.read(fd, Buffer.alloc(length), 0, length, resourceOffset, function (error, bytesRead, result) {\r\n                    if (error) {\r\n                        return fs_1.close(fd, function () {\r\n                            callback(error, null);\r\n                        });\r\n                    }\r\n                    fs_1.close(fd, function (err) {\r\n                        if (err) {\r\n                            return callback(err, result);\r\n                        }\r\n                        callback(err, encoding ? result.toString(encoding) : result);\r\n                    });\r\n                });\r\n            });\r\n        },\r\n        createReadStream: function createReadStream(file, options) {\r\n            setupManifest_1();\r\n            var entry = manifest[file];\r\n            if (!entry || !isString(file)) {\r\n                return originalCreateReadStream_1.apply(fs_1, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart_1 + offset;\r\n            var opts = !options ? {} : isString(options) ? { encoding: options } : options;\r\n            return fs_1.createReadStream(process.execPath, Object.assign({}, opts, {\r\n                start: resourceOffset,\r\n                end: resourceOffset + length\r\n            }));\r\n        },\r\n        readFileSync: function readFileSync(file, options) {\r\n            setupManifest_1();\r\n            var entry = manifest[file];\r\n            if (!entry || !isString(file)) {\r\n                return originalReadFileSync_1.apply(fs_1, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart_1 + offset;\r\n            var encoding = isString(options) ? options : null;\r\n            var fd = fs_1.openSync(process.execPath, 'r');\r\n            var result = Buffer.alloc(length);\r\n            fs_1.readSync(fd, result, 0, length, resourceOffset);\r\n            fs_1.closeSync(fd);\r\n            return encoding ? result.toString(encoding) : result;\r\n        },\r\n        statSync: function statSync(path) {\r\n            var stat = ownStat_1(path);\r\n            if (stat) {\r\n                return stat;\r\n            }\r\n            return originalStatSync_1.apply(fs_1, arguments);\r\n        },\r\n        stat: function stat(path, callback) {\r\n            var stat = ownStat_1(path);\r\n            if (stat) {\r\n                process.nextTick(function () {\r\n                    callback(null, stat);\r\n                });\r\n            }\r\n            else {\r\n                return originalStat_1.apply(fs_1, arguments);\r\n            }\r\n        }\r\n    };\r\n    Object.assign(fs_1, nfs);\r\n}\r\n"));
    }
    //compiler.shims.push(wrap('{/{replace:lib/steps/shim-require.js}}'))
    if (compiler.options.fakeArgv !== false) {
        var nty = !process.stdin.isTTY;
        var input = nty ? '[stdin]' : JSON.stringify(compiler.options.input);
        compiler.shims.push(wrap("\n      var r = require('path').resolve; \n      process.argv.splice(1,0, " + (nty ? "'" + input + "'" : "r(" + input + ")") + ");"));
    }
    return next();
}
exports.default = default_1;
